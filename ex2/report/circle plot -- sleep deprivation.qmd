---
title: "Circle Plot: sleep deprivation"
format: pdf
lang: en-GB
editor: 
  markdown:
      wrap: 62
---
<!--- #fontfamily: "Arial" -->
```{r ..}

# Final plot here

```

{{< pagebreak >}}


Here I will further investigate the use of circle plot by focusing on a different aspect.<!--- WHICH ASPECT?-->

First, I combine the data probe and the sleep. The data used for this exploration has been downloaded from OSF (https://osf.io/xq6wr/).

```{r packages}
library(tidyverse)
# loader script
list.files("../data", pattern=".rdata", full.names = T,ignore.case = T) -> files
for(x in files){load(x)}

```

Before we start, some minor changes to the data frame will be done to make the plots look better and make them easier to work with. 

<!--- CHECK IF IT IS NECESSARY WITH BEHAVIOUR PERFORMANCE! -->

```{r start}
sleep_diary |>
  mutate(sleepdep = factor(if_else(pre_control==1, "NS",
                           ifelse(pre_sleepdep==1, "PSD", NA)), levels = c("PSD","NS")), 
         subj = as.numeric(subj) 
         ) |>
  filter(!(is.na(sleepdep))) -> sleep
```

According to the draft idea, I believe it is best to plot the data according to sleep time and sleep duration. More specifically, the x-variable containing the time that participants fell asleep, and the y-variable relating to the amount of sleep participant received. This will be split into their respective conditions and in this way, we should see that participants go to sleep later, and sleep less. 

```{r simple point over all associations}
sleep |>
  ggplot(aes(x=sleep_time, y=sleep_duration, col=sleepdep))+
  geom_point()
  
```

As expected, participants did go to sleep later during the PSD (SD) condition and slept fewer hours as compared to the NS (control). However, a problem with this plot is that it visualizes all the (three) data points pertaining to participants sleep in each condition. To more effectively visualize with a circle plot, I should use a summary statistic of each the sleep. 

<!--- Illustrate data plot with labels attached to each data point? -->
<!--- Illustrate data plot with labels attached to each data point? -->
<!--- Illustrate data plot with labels attached to each data point? -->

To illustrate my point, we can visualize sleep duration over each subject, split by condition. 

```{r summary over subj and sleepdep}
sleep |>
  ggplot(aes(x=subj, y=sleep_duration, col=sleepdep))+
  geom_point(position=position_dodge(.8), size=1, alpha=.6)+
  stat_summary()
```

This plot produce a summary statistic (mean_se) over each subject for each condition. The result is more of what I am looking for. However, this plot is missing the relation to sleep time, which has to be represented by one of the axis. There is a problem related to this, however, in that each sleep duration point has a related sleep time point. This means that there is an association between all the data points for our plot, and grouping/summarizing within the ggplot is hard (if not impossible). One work around is to transform the data before we plug it into ggplot. 

```{r start plot}
sleep |>
  group_by(subj) |>
  summarize(
    # Mean sleep duration over participant by condition 
    NS_duration = mean(sleep_duration[sleepdep=="NS"], na.rm=T),
    PSD_duration = mean(sleep_duration[sleepdep=="PSD"], na.rm=T),
    # mean sleep time over participant by condition
    NS_sleep = mean(sleep_time_cum[sleepdep=="NS"], na.rm=T),
    NS_sleep = ifelse(NS_sleep>=24, NS_sleep-24, NS_sleep),
      #' Fix to standard clock time
    PSD_sleep = mean(sleep_time_cum[sleepdep=="PSD"], na.rm=T),
    PSD_sleep = ifelse(PSD_sleep>=24, PSD_sleep-24, PSD_sleep),
    # mean wake time over participant by condition
    NS_wake = mean(last_awaking_fix[sleepdep=="NS"], na.rm=T),
    PSD_wake = mean(last_awaking_fix[sleepdep=="PSD"], na.rm=T),
    ) |> 
  pivot_longer(c(starts_with("NS"), starts_with("PSD")), 
               names_pattern = "(.*)_(.*)",
               names_to=c("sleepdep", ".value")) |>
  mutate(sleepdep=factor(sleepdep, levels=c("PSD", "NS"))) |> 
  ggplot(aes(x=sleep, y=duration, fill=sleepdep, col=sleepdep))+
  geom_point(size=2)
```

This result in a plot that seem to contain more of what I am looking for. Another thing that could be added to the plot is some uncertainty relating to the data. For instance, by using standard error, standard deviation or confidence intervals. For now I will stick with standard error, but this can easily be changed later. 

```{r transformation and simple vis}
sleep |>
  group_by(sleepdep) |>
  mutate(sd_length = length(sleepdep)) |> ungroup() |>
  group_by(subj, sleepdep) |>
  reframe(
    # Mean sleep duration
    duration = mean(sleep_duration, na.rm=T),
    duration_sd = sd(sleep_duration, na.rm=T),
    duration_se = sd(sleep_duration, na.rm=T) / sqrt(sd_length),
    # mean sleep time over participant by condition
    sleep = mean(sleep_time_cum, na.rm=T),
    sleep = ifelse(sleep>=24, sleep-24, sleep),
    sleep_sd = sd(sleep_time_cum, na.rm=T), 
    sleep_se = sd(sleep_time_cum, na.rm=T) / sqrt(sd_length),
    # mean wake time over participant by condition
    waking = mean(last_awaking_fix, na.rm=T),
    waking_sd = sd(last_awaking_fix, na.rm=T),
    waking_se = sd(last_awaking_fix, na.rm=T) / sqrt(sd_length),) |> 
  unique() -> s_sleep

s_sleep |>  
  ggplot(aes(x=sleep, y=duration, col=sleepdep))+
  geom_point(size=1.5)+
  geom_errorbar(aes(ymin=duration-duration_se, ymax=duration+duration_se))
```

Here I improved upon the data transformation and included a calculation of the standard error (SE) and standard deviation (SD). This will be used to indicate some uncertainty in our estimate or indicate the variation of the data. As noted previously, circle plots are more apt at visualizing summarized data than the raw data. In particular, when the data points cluster on or near each other, as the circle plot transform the layout of the plot in such a way as to make it difficulty to read or interpret. With this, we can proceed to make it circular.

Before we move on, I would like to quickly investigate whether to stick with SD or SE. To me SD appear to be more informative as it indicate, to some degree, the width of the data. However, exactly why the width of the data is important or interesting may be more difficult to justify. In our case, the SD indicate variation in sleep time. Since we are estimating participants sleep duration, their SD should (hopefully) be rather small, indicating more consistent sleep duration. On the other hand, visualizing SE would indicate the error of the estimate, which also partially indicate that the uncertainty is wider, although it does not really indicate just how wide - in my opinion. To do this, we simply change the calculated "_se" to "_sd" in the "linerange" argument. 

```{r SD test}
s_sleep |>
  ggplot(aes(x=sleep, y=duration, col=sleepdep))+
  geom_point()+
  geom_linerange(aes(ymin=duration-duration_sd,ymax=duration+duration_sd))
```

Although I would argue that SD may be more informative, it adds a lot of overlap with our data estimates. Which does not bode well for visualizing the data circularly. Indeed, it is rather difficult to even see all the estimated points in this plot.

```{r circluar SD test}
s_sleep |>
  ggplot(aes(x=sleep, y=duration, col=sleepdep))+
  geom_point()+
  geom_linerange(aes(ymin=duration-duration_sd,ymax=duration+duration_sd))+
  coord_polar()+
  geom_blank(aes(y=3))

```

Indeed, with the SD in the circular plot, it turns it to a mess. It even seems like some points are lost in the soup of the PSD sleep times.  Thus, for further investigation I will stick with SE, which makes the data points more readable, unless otherwise noted. 

```{r better transformation and circle plot}
sleep |>
  group_by(sleepdep) |>
  mutate(sd_length = length(sleepdep)) |> ungroup() |>
  group_by(subj, sleepdep) |>
  mutate(
    # Mean sleep duration
    duration = mean(sleep_duration, na.rm=T),
    duration_sd = sd(sleep_duration, na.rm=T),
    duration_se = sd(sleep_duration, na.rm=T) / sqrt(sd_length),
    # mean sleep time over participant by condition
    sleep = mean(sleep_time_cum, na.rm=T),
    sleep = ifelse(sleep>=24, sleep-24, sleep),
        # could add clock time here
    sleep_sd = sd(sleep_time_cum, na.rm=T), 
    sleep_se = sd(sleep_time_cum, na.rm=T) / sqrt(sd_length),
    # mean wake time over participant by condition
    waking = mean(last_awaking_fix, na.rm=T),
    waking_sd = sd(last_awaking_fix, na.rm=T),
    waking_se = sd(last_awaking_fix, na.rm=T) / sqrt(sd_length),) |> 
  unique() |>
  ggplot(aes(x=sleep, y=duration, col=sleepdep))+
  geom_point(size=1.5)+
  geom_errorbar(aes(ymin=duration-duration_se, ymax=duration+duration_se))+
  coord_polar() -> sobj1
sobj1
```

Now we can start by making the circle plot more neat. Firstly, the data points all seem to cluster in around 2-3 hours, at least for the PSD condition. We can change this by placing an invisible point closer to the center, which will increase the distance a bit. Moreover, we can change the sleep to a 24 hour clock, indicating when participants went to sleep. 

```{r}
sobj1 +
  geom_blank(aes(x=1,y=3))+ # Add an empty element too add some distances from the center
  scale_x_continuous(breaks = seq(0,24,1), limits = c(0,NA), minor_breaks = F)+ # Limits add 0
  scale_y_continuous(breaks = seq(4,10,1))+
  theme_minimal()+
  labs(x="Sleep time", y="Sleep duration", fill="Condition", col="Condition") -> sobj2
sobj2
```

In this plot, the x-axis represents the time at which participants fell asleep, while the y-axis represents the amount of sleep participants received. From the plot, we can clearly see that during the NS condition, participants went to sleep earlier and slept for longer as compared to the PSD condition. During the PSD condition, participants went to sleep later, and also slept shorter (indicated with points closer to the center.

With the previous plot we are able to approximate when participants went to sleep, and approximately how long they slept. We could possibly make this more clear by using the cumulative sum of the clock instead of a 24 hour clock.

```{r}
sleep |>
  ggplot(aes(x=sleep_time_cum, y=sleep_duration, col=sleepdep))+
  geom_point()
```

Firstly, with this plot we can clearly see a downward trend for the sleep duration plotted against the sleep time. Keeping the data in this way may be easier to work with in the future, and we can easily change the appears of the x-axis to the appropriate time (i.e., 0, 1, 2, etc.).

```{r}
sleep |>
  ggplot(aes(x=sleep_time_cum, y=sleep_duration, col=sleepdep))+
  geom_point()+
  scale_x_continuous(breaks=seq(0,31,1), labels=c(seq(0,24,1), seq(1,7,1)))
```

This looks similar to previously (which is good), but it should now be easier to work with.

```{r}
sleep |>
  group_by(sleepdep) |>
  mutate(sd_length = length(sleepdep)) |> ungroup() |>
  group_by(subj, sleepdep) |>
  mutate(
    # Mean sleep duration
    duration = mean(sleep_duration, na.rm=T),
    duration_sd = sd(sleep_duration, na.rm=T),
    duration_se = sd(sleep_duration, na.rm=T) / sqrt(sd_length),
    # mean sleep time over participant by condition
    sleep = mean(sleep_time_cum, na.rm=T),
        # could add clock time here
    sleep_sd = sd(sleep_time_cum, na.rm=T), 
    sleep_se = sd(sleep_time_cum, na.rm=T) / sqrt(sd_length),
    # mean wake time over participant by condition
    waking = mean(last_awaking_fix, na.rm=T),
    waking_sd = sd(last_awaking_fix, na.rm=T),
    waking_se = sd(last_awaking_fix, na.rm=T) / sqrt(sd_length),
    ) -> s_sleep2

s_sleep2 |> 
  ggplot(aes(x=sleep, y=duration, col=sleepdep))+
  geom_point()+
  geom_linerange(aes(ymin=duration-duration_se, ymax=duration+duration_se, x=sleep))+
  # add NS mean line
  geom_linerange(aes(y=mean(duration), xmin=min(sleep), xmax=max(sleep)), 
                 s_sleep2 |> filter(sleepdep=="NS"))+
  # Add PSD mean line
  geom_linerange(aes(y=mean(duration), xmin=min(sleep), xmax=max(sleep)), 
                 s_sleep2 |> filter(sleepdep=="PSD"))+
  scale_x_continuous(breaks=seq(0,31,1), labels=c(seq(0,24,1), seq(1,7,1)))
  
  coord_polar()

-> sobj10
sobj10
```

To this end, it is now a rather easy to add a mean line of sleep duration for each conditions. With this, we can clearly see that participants, in general, slept less during the PSD condition than the NS condition. 

```{r}

  scale_x_continuous(breaks=seq(0,31,1), labels=c(seq(0,24,1), seq(1,7,1)))
```







To further improve on the plot we can add mean lines for each of the conditions to be more able to split the differences between the conditions. 
# This is terribly hard b/c we do not use cum clock. Maybe investigate cum clock instead of standard clock?  indeed just use cum and change the labels. Or rather transform data to TIME objects which might be easier to work with? 

```{r}
sobj2 +
  geom_linerange(aes(xmin=sleep, xmax=23.99, y=mean(duration)),
                 data = s_sleep |> filter(sleepdep=="NS"))

  geom_smooth(data=sleep, mapping=aes(x=sleep_time_cum, y=sleep_duration)) # this ends up weird.
  geom_ribbon(data=
                sleep |> group_by(sleepdep) |>
                summarize(duration_m = mean(sleep_duration, na.rm=T), 
                          sleep_min = min(sleep_time_cum, na.rm=T),
                          sleep_max = max(sleep_time_cum, na.rm=T)), #|> pivot_wider(names_from = sleepdep, values_from=everything()),
              mapping=aes(xmin=sleep_min, xmax=sleep_max, y=duration_m))
              #mapping=aes(xmin=sleep_min_NS, xmax=sleep_max_NS, y=duration_m_NS))
```






# this is useless

```{r}
s_sleep

a<- function(x){
  h <- hours(floor(x))
  m <- (x-floor(x))*60
  s <- (m-floor(m))*60
  
  m<- minutes(floor(m))
  s<- seconds(round(s))
  
  h+m+s -> a
  hms(a)
  return(a)
}

# This will not work
s_sleep |> 
  mutate(across(5:length(s_sleep), a)) -> test


strftime(Sys.time(), format = "%H:%M:%S")
strftime("23:50:23", format = "%H:%M:%S")

test |>
  ggplot(aes(x=sleep,y=duration))+

```
















We can add the wake time and connect these with lines, (but this is probably messy...)

```{r}
sobj2 +
  geom_point(aes(x = waking, y=duration, col=sleepdep))
```













checking the dimensions of the df (indicate the reduction in data points. )

```{r}
# slp |> #dim()
#   filter(subj, sleepdep) |> dim()
#   group_by(subj, sleepdep) |> dim()
```





<!--- Probably leave this out -->

<!--- This is with data -->
```{r}
# # dont make dis hard for me, thx
# 
# # Join diary & data
# sleep_diary |>
#   mutate(subj=as.numeric(subj),
#          sleepdep = ifelse(pre_control==1, "control",
#                            ifelse(pre_sleepdep==1, "SD", NA))) |> 
#           #' Add common var
#   left_join(data.probe, # behaviour data
#           by=c("subj", "sleepdep")) |>
#   mutate(sleepdep = factor(
#     fct_recode(sleepdep, NS="control", PSD="SD"), levels = c("PSD","NS"))) -> sleep_and_data
# 
# # data filtering & changes
# sleep_and_data |>
#   filter(!(is.na(sleepdep))) -> slp
```



